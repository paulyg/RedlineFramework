<?php
/**
 * @package RedlineFramework
 * @author Paul Garvin <paul@paulgarvin.net>
 * @copyright Copyright 2011 Paul Garvin. Some rights reserved.
 * @license http://www.gnu.org/licenses/gpl-3.0-standalone.html GNU General Public License
 * @version @package_version@
 *
 * Redline PHP Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Redline PHP Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Redline PHP Framework. If not, see <http://www.gnu.org/licenses/>.
 */
namespace Redline\Router;

/**
 * Represents a single URI path definition.
 *
 * @package RedlineFramework
 */
class Route implements RouteInterface
{
	/**
	 * Unique name or identifier of this route
	 * @var string
	 */
	protected $name;

    /**
	 * Regex patttern that will be used for matching.
	 * @var string
	 */
	protected $pattern;

    /**
	 * Original path spec, before being converted to a regex pattern.
	 * @var string
	 */
	protected $path;

    /**
	 * Regex pattern conditions to be applied to the path spec.
	 * @var array
	 */
	protected $conditions;

    /**
	 * Default values for the named path segments.
	 * @var array
	 */
	protected $default;

    /**
	 * List of HTTP methods this route may be used with.
	 * @var array
	 */
	protected $methods;

    /**
     * Controller specification indicating class and method the be invoked.
     * @var string
     */
    protected $controller;

	/**
	 * Array of parameter names and values captured by routing match.
	 * @var array
	 */
	protected $params = array();

	/**
	 * Construct a new BasicRoute.
     *
	 * @param string $path URL path specification to match route against.
	 * @param string $controller_spec Special format indicating module, controller class & action to call.
     * @param string $name Omit to have the name autogenerated from module, controller, & action.
	 * @param array  $options Method, conditions, and default param values, path prefix, name prefix.
	 */
	public function __construct($path, $controller_spec, $name = '', array $options = array())
	{
        if (is_array($name)) {
            $options = $name;
            $name = '';
        }

		if (isset($options['path_prefix'])) {
            $path = rtrim($options['path_prefix'], '/') . '/' . ltrim($path, '/');
        }

        $this->conditions = isset($options['conditions']) ? $options['conditions'] : array();
        $this->defaults = isset($options['defaults']) ? $options['defaults'] : array();

        $this->path = $path;

        // Hash char must not be 1st char so we accept 0 as false instead of using === false
        if (!is_callable($controller_spec) && substr_count($controller_spec, '#') !== 1) {
            throw new Exception("The controller specification '$controller_spec' does not contain a controller class and action seperated by the '#' character.");
        }
        $this->controller = $controller_spec;

        if (empty($name) && !is_callable($controller_spec)) {  
            list($controller, $action) = explode('#', $controller_spec);

            if (strpos($controller, '@') === 0) {
                list($module, $controller) = explode('\\', $controller, 2);
            }

            $name = str_replace('\\', '_', $controller) . '_' . $action;
        }

        if (isset($options['name_prefix'])) {
            $name = $options['name_prefix'] . '_' . $name;
        }
        $this->name = $name;
	}

	/**
     * Test whether given URL path matches the route.
	 *
	 * @param string $path URL path to test for match against.
	 * @return boolean
     */
    public function match($uri_path)
    {
        if (empty($this->pattern)) {
            $this->compilePattern();
        }

        if (preg_match("@^{$this->pattern}$@", $uri_path, $param_matches) {
            $params = $this->defaults;
            array_shift($param_matches);
            foreach ($param_matches as $key => $val) {
                if (is_string($key)) {
                    $params[$key] = $val;
                }
            }
            $this->params = $params;

            return true;
        }
        return false;
    }

    /**
     * Create the regex pattern to be matched against the requested URI path.
     *
     * Creating the regex pattern is done "lazily", only when we are asked to do a match
     * for performance reasons.
     * 
     * @return void
     */
    protected function compilePattern()
    {
        $pattern = str_replace(')', ')?' $this->path);
        preg_match_all('@:([\w]+)@', $pattern, $param_names, PREG_PATTERN_ORDER);
        $param_names = $param_names[0];

        if ($param_names) {
            $names = array();
            $conditions = array();
            foreach ($param_names as $key) {
                $condition = isset($this->conditions[$key]) ? $this->conditions[$key] : '([^/]+)';
                $names[] = ':' . $key;
                $conditions[] = "(?P<$key>" . substr($condition, 1);
            }
            $pattern = str_replace($names, $conditions, $pattern)
        }
        $this->pattern = $pattern;
    }

    /**
     * Build a URL path from given parameter values.
     *
     * @param array $params Parameter names and values.
     * @return string
     */
    public function build($params)
    {
        $keys = array();
        $vals = array();
        $params= array_merge($this->defaults, $params);
        foreach ($params as $key => $val) {
            $keys[] = ':' . $key;
            $vals = urlencode($val);
        }
        return str_replace($keys, $vals, $this->path);
    }

    /**
     * Return the name (identifier) for this route.
     *
     * @return string
     */
    public function name()
    {
        return $this->name;
    }

    /**
     * Return the compiled regex pattern used to match this route.
     *
     * @return string
     */
    public function pattern()
    {
        if (empty($this->pattern)) {
            $this->compilePattern();
        }
        return $this->pattern;
    }

    /**
     * Return the URL path used to define this route.
     *
     * @return string
     */
    public function path()
    {
        return $this->path;
    }

    /**
     * Return the HTTP methods allowed for this route.
     *
     * @return array
     */
    public function methods()
    {
        return $this->methods;
    }

    /**
     * Return the controller specification string or callback represented by this route.
     *
     * @return string
     */
    public function getController()
    {
        return $this->controller;
    }

    /**
     * Retrieve the parameters captured from the URL pattern during the match.
     *
     * @return array
     */
    public function getParams()
    {
        return $this->params;
    }
}
